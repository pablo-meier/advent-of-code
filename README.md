# Advent of Code

Solutions for [Advent of Code][1], shown to me by a [coworker][2].

Each day is done in a different language:

* [Day 1](/day1): Standard ML ([impl](http://mlton.org/), [description](https://en.wikipedia.org/wiki/Standard_ML))
* [Day 2](/day2): Factor ([impl](http://factorcode.org/), [description](https://en.wikipedia.org/wiki/Factor_(programming_language))
* [Day 3](/day3): Racket ([impl](http://racket-lang.org/), [description](https://en.wikipedia.org/wiki/Racket_(programming_language)))
* [Day 4](/day4): Ruby ([impl](https://www.ruby-lang.org/en/), [description](https://en.wikipedia.org/wiki/Ruby_(programming_language)))
* [Day 5](/day5): Go ([impl](https://golang.org/), [description](https://en.wikipedia.org/wiki/Go_(programming_language)))
* [Day 6](/day6): C ([impl](http://clang.llvm.org/), [description](https://en.wikipedia.org/wiki/C_(programming_language)))
* [Day 7](/day7): Prolog ([impl](http://www.swi-prolog.org/), [description](https://en.wikipedia.org/wiki/Prolog))
* [Day 8](/day8): Haskell ([impl](https://www.haskell.org/platform/), [description](https://en.wikipedia.org/wiki/Haskell_(programming_language)))
* [Day 9](/day9): Erlang ([impl](https://www.erlang.org/), [description](https://en.wikipedia.org/wiki/Erlang_(programming_language))))
* [Day 10](/day10): C++ ([impl](http://clang.llvm.org/), [description](https://en.wikipedia.org/wiki/C%2B%2B))
* [Day 11](/day11): Common Lisp ([impl](http://www.sbcl.org), [description](https://en.wikipedia.org/wiki/Common_Lisp))
* [Day 12](/day12): Rust ([impl](https://www.rust-lang.org), [description](https://en.wikipedia.org/wiki/Rust_(programming_language)))
* [Day 13](/day13): Python ([impl](https://www.python.org/), [description](https://en.wikipedia.org/wiki/Python_(programming_language))))
* [Day 14](/day14): Java ([impl](https://www.java.com/en/), [description](https://en.wikipedia.org/wiki/Java_(programming_language)))
* [Day 15](/day15): JavaScript ([impl](https://nodejs.org/en/), [description](https://en.wikipedia.org/wiki/JavaScript))
* [Day 16](/day16): Pyret ([website](https://www.pyret.org/)) and OCaml ([impl](http://www.ocaml.org/)), [description](https://en.wikipedia.org/wiki/OCaml))
* [Day 17](/day17): Scala ([impl](https://www.scala-lang.org/)), [description](https://en.wikipedia.org/wiki/Scala_(programming_language)))
* [Day 18](/day18): Elixir ([impl](http://elixir-lang.org), [description](https://en.wikipedia.org/wiki/Elixir_(programming_language)))
* [Day 19](/day19): Mercury ([impl](https://mercurylang.org), [description](https://en.wikipedia.org/wiki/Mercury_(programming_language))))
* [Day 20](/day20): Clojure ([impl](https://clojure.org/), [description](https://en.wikipedia.org/wiki/Clojure)) 
* [Day 21](/day21): Lua ([impl](https://www.lua.org/), [description](https://en.wikipedia.org/wiki/Lua_(programming_language)))

Let's see if I can keep it up!

## Potential solutions inâ€¦

* F#
* Idris
* Nim
* Crystal
* Smalltalk
* Swift
* Ada
* FORTRAN
* COBOL
* Eiffel
* Io
* Self
* Kotlin
* Elm
* PHP
* Shen
* Pure
* J
* Orc

Suggestions welcome!

## TODOs

* Ideally, blog a bit about this project and the languages.
* Ensure we use stdin/file input wherever possible, rather than hard code the puzzle inputs.
* More idiomatic refactors of many of the later ones, not just "You can code Scheme in any language."

   [1]: http://adventofcode.com/
   [2]: https://github.com/philiphwang
